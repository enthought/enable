# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_gl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_gl')
    _gl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_gl', [dirname(__file__)])
        except ImportError:
            import _gl
            return _gl
        try:
            _mod = imp.load_module('_gl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _gl = swig_import_helper()
    del swig_import_helper
else:
    import _gl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


def iround(*args):
    return _gl.iround(*args)
iround = _gl.iround

def uround(*args):
    return _gl.uround(*args)
uround = _gl.uround

def ifloor(*args):
    return _gl.ifloor(*args)
ifloor = _gl.ifloor

def ufloor(*args):
    return _gl.ufloor(*args)
ufloor = _gl.ufloor

def iceil(*args):
    return _gl.iceil(*args)
iceil = _gl.iceil

def uceil(*args):
    return _gl.uceil(*args)
uceil = _gl.uceil
cover_shift = _gl.cover_shift
cover_size = _gl.cover_size
cover_mask = _gl.cover_mask
cover_none = _gl.cover_none
cover_full = _gl.cover_full
poly_subpixel_shift = _gl.poly_subpixel_shift
poly_subpixel_scale = _gl.poly_subpixel_scale
poly_subpixel_mask = _gl.poly_subpixel_mask
fill_non_zero = _gl.fill_non_zero
fill_even_odd = _gl.fill_even_odd

def deg2rad(*args):
    return _gl.deg2rad(*args)
deg2rad = _gl.deg2rad

def rad2deg(*args):
    return _gl.rad2deg(*args)
rad2deg = _gl.rad2deg
path_cmd_stop = _gl.path_cmd_stop
path_cmd_move_to = _gl.path_cmd_move_to
path_cmd_line_to = _gl.path_cmd_line_to
path_cmd_curve3 = _gl.path_cmd_curve3
path_cmd_curve4 = _gl.path_cmd_curve4
path_cmd_curveN = _gl.path_cmd_curveN
path_cmd_catrom = _gl.path_cmd_catrom
path_cmd_ubspline = _gl.path_cmd_ubspline
path_cmd_end_poly = _gl.path_cmd_end_poly
path_cmd_mask = _gl.path_cmd_mask
path_flags_none = _gl.path_flags_none
path_flags_ccw = _gl.path_flags_ccw
path_flags_cw = _gl.path_flags_cw
path_flags_close = _gl.path_flags_close
path_flags_mask = _gl.path_flags_mask

def is_vertex(*args):
    return _gl.is_vertex(*args)
is_vertex = _gl.is_vertex

def is_drawing(*args):
    return _gl.is_drawing(*args)
is_drawing = _gl.is_drawing

def is_stop(*args):
    return _gl.is_stop(*args)
is_stop = _gl.is_stop

def is_move_to(*args):
    return _gl.is_move_to(*args)
is_move_to = _gl.is_move_to

def is_line_to(*args):
    return _gl.is_line_to(*args)
is_line_to = _gl.is_line_to

def is_curve(*args):
    return _gl.is_curve(*args)
is_curve = _gl.is_curve

def is_curve3(*args):
    return _gl.is_curve3(*args)
is_curve3 = _gl.is_curve3

def is_curve4(*args):
    return _gl.is_curve4(*args)
is_curve4 = _gl.is_curve4

def is_end_poly(*args):
    return _gl.is_end_poly(*args)
is_end_poly = _gl.is_end_poly

def is_close(*args):
    return _gl.is_close(*args)
is_close = _gl.is_close

def is_next_poly(*args):
    return _gl.is_next_poly(*args)
is_next_poly = _gl.is_next_poly

def is_cw(*args):
    return _gl.is_cw(*args)
is_cw = _gl.is_cw

def is_ccw(*args):
    return _gl.is_ccw(*args)
is_ccw = _gl.is_ccw

def is_oriented(*args):
    return _gl.is_oriented(*args)
is_oriented = _gl.is_oriented

def is_closed(*args):
    return _gl.is_closed(*args)
is_closed = _gl.is_closed

def get_close_flag(*args):
    return _gl.get_close_flag(*args)
get_close_flag = _gl.get_close_flag

def clear_orientation(*args):
    return _gl.clear_orientation(*args)
clear_orientation = _gl.clear_orientation

def get_orientation(*args):
    return _gl.get_orientation(*args)
get_orientation = _gl.get_orientation

def set_orientation(*args):
    return _gl.set_orientation(*args)
set_orientation = _gl.set_orientation
CAP_ROUND = _gl.CAP_ROUND
CAP_BUTT = _gl.CAP_BUTT
CAP_SQUARE = _gl.CAP_SQUARE
JOIN_ROUND = _gl.JOIN_ROUND
JOIN_BEVEL = _gl.JOIN_BEVEL
JOIN_MITER = _gl.JOIN_MITER
FILL = _gl.FILL
EOF_FILL = _gl.EOF_FILL
STROKE = _gl.STROKE
FILL_STROKE = _gl.FILL_STROKE
EOF_FILL_STROKE = _gl.EOF_FILL_STROKE
nearest = _gl.nearest
bilinear = _gl.bilinear
bicubic = _gl.bicubic
spline16 = _gl.spline16
spline36 = _gl.spline36
sinc64 = _gl.sinc64
sinc144 = _gl.sinc144
sinc256 = _gl.sinc256
blackman64 = _gl.blackman64
blackman100 = _gl.blackman100
blackman256 = _gl.blackman256
pix_format_undefined = _gl.pix_format_undefined
pix_format_gray8 = _gl.pix_format_gray8
pix_format_rgb555 = _gl.pix_format_rgb555
pix_format_rgb565 = _gl.pix_format_rgb565
pix_format_rgb24 = _gl.pix_format_rgb24
pix_format_bgr24 = _gl.pix_format_bgr24
pix_format_rgba32 = _gl.pix_format_rgba32
pix_format_argb32 = _gl.pix_format_argb32
pix_format_abgr32 = _gl.pix_format_abgr32
pix_format_bgra32 = _gl.pix_format_bgra32
end_of_pix_formats = _gl.end_of_pix_formats
blend_normal = _gl.blend_normal
blend_copy = _gl.blend_copy
end_of_e = _gl.end_of_e
marker_square = _gl.marker_square
marker_diamond = _gl.marker_diamond
marker_circle = _gl.marker_circle
marker_crossed_circle = _gl.marker_crossed_circle
marker_semiellipse_left = _gl.marker_semiellipse_left
marker_semiellipse_right = _gl.marker_semiellipse_right
marker_semiellipse_up = _gl.marker_semiellipse_up
marker_semiellipse_down = _gl.marker_semiellipse_down
marker_triangle_left = _gl.marker_triangle_left
marker_triangle_right = _gl.marker_triangle_right
marker_triangle_up = _gl.marker_triangle_up
marker_triangle_down = _gl.marker_triangle_down
marker_four_rays = _gl.marker_four_rays
marker_cross = _gl.marker_cross
marker_x = _gl.marker_x
marker_dash = _gl.marker_dash
marker_dot = _gl.marker_dot
marker_pixel = _gl.marker_pixel
end_of_markers = _gl.end_of_markers

from numpy import ndarray

def is_array(obj):
    return type(obj) is ndarray

def is_correct_type(obj, numpy_type):
    return is_array(obj) and (obj.dtype == numpy_type)

def numpy_check(obj, typecode,
                exact_size = [],
                must_be_contiguous = 1,
                allow_coersion = 0):

    if is_correct_type(obj, typecode):
        ary = obj
    elif allow_coersion:
        ary = asarray(obj,typecode)
    else:
        raise TypeError("input is not an array or the array has the wrong type")

    if must_be_contiguous and not ary.flags["CONTIGUOUS"]:
        if allow_coersion:
            ary = ary.copy()
        else:
            raise TypeError("input array must be contiguous")

# check number of dimensions
    required_dims = len(exact_size)
    if required_dims and required_dims != len(ary.shape):
        raise ValueError("The input array does not have the correct shape")

# check exact shape of each dimension
    cnt = 0
    for desired,actual in zip(exact_size,ary.shape):
        if desired != -1 and desired != actual:
            raise ValueError("The %d dimensions of the array has the wrong shape" % (cnt))
        cnt += 1

    return ary


def path_cmd(*args):
    return _gl.path_cmd(*args)
path_cmd = _gl.path_cmd

def path_flags(*args):
    return _gl.path_flags(*args)
path_flags = _gl.path_flags


#----------------------------------------------------------------------------
#
# map strings values to the marker enumerated values and back with:
#   marker_string_map[string] = enum
#   marker_enum_map[enum] = string
#
#----------------------------------------------------------------------------

kiva_marker_to_agg = {}
kiva_marker_to_agg[1] = marker_square
kiva_marker_to_agg[2] = marker_diamond
kiva_marker_to_agg[3] = marker_circle
kiva_marker_to_agg[4] = marker_crossed_circle
kiva_marker_to_agg[5] = marker_x
kiva_marker_to_agg[6] = marker_triangle_up
kiva_marker_to_agg[7] = marker_triangle_down
kiva_marker_to_agg[8] = marker_cross    # "plus" sign; Agg calls this "cross"
kiva_marker_to_agg[9] = marker_dot
kiva_marker_to_agg[10] = marker_pixel


#----------------------------------------------------------------------------
#
# Map strings values to the pix_format enumerated values and back with:
#   pix_format_string_map[string] = enum
#   pix_format_enum_map[enum] = string
#
#----------------------------------------------------------------------------

pix_format_string_map = {}
pix_format_string_map["gray8"] = pix_format_gray8
pix_format_string_map["rgb555"] = pix_format_rgb555
pix_format_string_map["rgb565"] = pix_format_rgb565
pix_format_string_map["rgb24"] = pix_format_rgb24
pix_format_string_map["bgr24"] = pix_format_bgr24
pix_format_string_map["rgba32"] = pix_format_rgba32
pix_format_string_map["argb32"] = pix_format_argb32
pix_format_string_map["abgr32"] = pix_format_abgr32
pix_format_string_map["bgra32"] = pix_format_bgra32

pix_format_enum_map = {}
for key,value in pix_format_string_map.items():
    pix_format_enum_map[value] = key

#----------------------------------------------------------------------------
# Map a pix format string value to the number of bytes per pixel
#----------------------------------------------------------------------------

pix_format_bytes = {}
pix_format_bytes["gray8"] = 1
pix_format_bytes["rgb555"] = 2
pix_format_bytes["rgb565"] = 2
pix_format_bytes["rgb24"] = 3
pix_format_bytes["bgr24"] = 3
pix_format_bytes["rgba32"] = 4
pix_format_bytes["argb32"] = 4
pix_format_bytes["abgr32"] = 4
pix_format_bytes["bgra32"] = 4

pix_format_bits = {}
pix_format_bits["gray8"] = 8
pix_format_bits["rgb555"] = 15
pix_format_bits["rgb565"] = 16
pix_format_bits["rgb24"] = 24
pix_format_bits["bgr24"] = 24
pix_format_bits["rgba32"] = 32
pix_format_bits["argb32"] = 32
pix_format_bits["abgr32"] = 32
pix_format_bits["bgra32"] = 32

#----------------------------------------------------------------------------
#
# Map strings values to the interpolation enumerated values and back with:
#   interp_string_map[string] = enum
#   interp_enum_map[enum] = string
#
#----------------------------------------------------------------------------

interp_string_map = {}
interp_string_map["nearest"] = nearest
interp_string_map["bilinear"] = bilinear
interp_string_map["bicubic"] = bicubic
interp_string_map["spline16"] = spline16
interp_string_map["spline36"] = spline36
interp_string_map["sinc64"] = sinc64
interp_string_map["sinc144"] = sinc144
interp_string_map["sinc256"] = sinc256
interp_string_map["blackman64"] = blackman64
interp_string_map["blackman100"] = blackman100
interp_string_map["blackman256"] = blackman256

interp_enum_map = {}
for key,value in interp_string_map.items():
    interp_enum_map[value] = key


class _Rgba(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Rgba, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Rgba, name)
    __swig_setmethods__["r"] = _gl._Rgba_r_set
    __swig_getmethods__["r"] = _gl._Rgba_r_get
    if _newclass:
        r = _swig_property(_gl._Rgba_r_get, _gl._Rgba_r_set)
    __swig_setmethods__["g"] = _gl._Rgba_g_set
    __swig_getmethods__["g"] = _gl._Rgba_g_get
    if _newclass:
        g = _swig_property(_gl._Rgba_g_get, _gl._Rgba_g_set)
    __swig_setmethods__["b"] = _gl._Rgba_b_set
    __swig_getmethods__["b"] = _gl._Rgba_b_get
    if _newclass:
        b = _swig_property(_gl._Rgba_b_get, _gl._Rgba_b_set)
    __swig_setmethods__["a"] = _gl._Rgba_a_set
    __swig_getmethods__["a"] = _gl._Rgba_a_get
    if _newclass:
        a = _swig_property(_gl._Rgba_a_get, _gl._Rgba_a_set)

    def __init__(self, *args):
        this = _gl.new__Rgba(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def gradient(self, *args):
        return _gl._Rgba_gradient(self, *args)

    def premultiply(self, *args):
        return _gl._Rgba_premultiply(self, *args)

    def __repr__(self, *args):
        return _gl._Rgba___repr__(self, *args)

    def __eq__(self, *args):
        return _gl._Rgba___eq__(self, *args)

    def asarray(self, *args):
        return _gl._Rgba_asarray(self, *args)
    __swig_destroy__ = _gl.delete__Rgba
    __del__ = lambda self: None
_Rgba_swigregister = _gl._Rgba_swigregister
_Rgba_swigregister(_Rgba)
cvar = _gl.cvar
pi = cvar.pi


def is_sequence(arg):
    try:
        len(arg)
        return 1
    except:
        return 0

# Use sub-class to allow sequence as input
class Rgba(_Rgba):
    def __init__(self,*args):
        if len(args) == 1 and is_sequence(args[0]):
            args = tuple(args[0])
            if len(args) not in [3,4]:
                raise ValueError("array argument must be 1x3 or 1x4")
        _Rgba.__init__(self,*args)


def rotation_matrix(*args):
    return _gl.rotation_matrix(*args)
rotation_matrix = _gl.rotation_matrix

def scaling_matrix(*args):
    return _gl.scaling_matrix(*args)
scaling_matrix = _gl.scaling_matrix

def translation_matrix(*args):
    return _gl.translation_matrix(*args)
translation_matrix = _gl.translation_matrix

def skewing_matrix(*args):
    return _gl.skewing_matrix(*args)
skewing_matrix = _gl.skewing_matrix
class _AffineMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _AffineMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _AffineMatrix, name)

    def __init__(self, *args):
        this = _gl.new__AffineMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __invert__(self, *args):
        return _gl._AffineMatrix___invert__(self, *args)

    def reset(self, *args):
        return _gl._AffineMatrix_reset(self, *args)

    def multiply(self, *args):
        return _gl._AffineMatrix_multiply(self, *args)

    def invert(self, *args):
        return _gl._AffineMatrix_invert(self, *args)

    def flip_x(self, *args):
        return _gl._AffineMatrix_flip_x(self, *args)

    def flip_y(self, *args):
        return _gl._AffineMatrix_flip_y(self, *args)

    def scale(self, *args):
        return _gl._AffineMatrix_scale(self, *args)

    def determinant(self, *args):
        return _gl._AffineMatrix_determinant(self, *args)

    def asarray(self, *args):
        return _gl._AffineMatrix_asarray(self, *args)

    def load_from(self, *args):
        return _gl._AffineMatrix_load_from(self, *args)

    def __repr__(self, *args):
        return _gl._AffineMatrix___repr__(self, *args)

    def __getitem__(self, *args):
        return _gl._AffineMatrix___getitem__(self, *args)

    def __eq__(self, *args):
        return _gl._AffineMatrix___eq__(self, *args)
    __swig_destroy__ = _gl.delete__AffineMatrix
    __del__ = lambda self: None
_AffineMatrix_swigregister = _gl._AffineMatrix_swigregister
_AffineMatrix_swigregister(_AffineMatrix)


def is_sequence(arg):
    try:
        len(arg)
        return 1
    except:
        return 0

# AffineMatrix sub-class to get around problems with adding
# a AffineMatrix constructor that accepts a numpy array
# as input.
class AffineMatrix(_AffineMatrix):
    def __init__(self, *args):
        if len(args) == 1 and is_sequence(args[0]):
            args = tuple(args[0])
            if len(args) != 6:
                raise ValueError("array argument must be 1x6")
        _AffineMatrix.__init__(self,*args)

    def __imul__(self, other):
        """ inplace multiply

            We don't use the C++ version of this because it ends up
            deleting the object out from under itself.
        """
        self.multiply(other)
        return self

class CompiledPath(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CompiledPath, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CompiledPath, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _gl.new_CompiledPath(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def remove_all(self, *args):
        return _gl.CompiledPath_remove_all(self, *args)

    def begin_path(self, *args):
        return _gl.CompiledPath_begin_path(self, *args)

    def close_path(self, *args):
        return _gl.CompiledPath_close_path(self, *args)

    def move_to(self, *args):
        return _gl.CompiledPath_move_to(self, *args)

    def line_to(self, *args):
        return _gl.CompiledPath_line_to(self, *args)

    def quad_curve_to(self, *args):
        return _gl.CompiledPath_quad_curve_to(self, *args)

    def curve_to(self, *args):
        return _gl.CompiledPath_curve_to(self, *args)

    def arc(self, *args):
        return _gl.CompiledPath_arc(self, *args)

    def arc_to(self, *args):
        return _gl.CompiledPath_arc_to(self, *args)

    def add_path(self, *args):
        return _gl.CompiledPath_add_path(self, *args)

    def lines(self, *args):
        return _gl.CompiledPath_lines(self, *args)

    def line_set(self, *args):
        return _gl.CompiledPath_line_set(self, *args)

    def rect(self, *args):
        return _gl.CompiledPath_rect(self, *args)

    def rects(self, *args):
        return _gl.CompiledPath_rects(self, *args)

    def translate_ctm(self, *args):
        return _gl.CompiledPath_translate_ctm(self, *args)

    def rotate_ctm(self, *args):
        return _gl.CompiledPath_rotate_ctm(self, *args)

    def scale_ctm(self, *args):
        return _gl.CompiledPath_scale_ctm(self, *args)

    def concat_ctm_agg(self, *args):
        return _gl.CompiledPath_concat_ctm_agg(self, *args)

    def set_ctm_agg(self, *args):
        return _gl.CompiledPath_set_ctm_agg(self, *args)

    def kivaaffine_to_aggaffine(self, ctm):
        return AffineMatrix(ctm[0,0], ctm[0,1], ctm[1,0], ctm[1,1],
                            ctm[2,0], ctm[2,1])
    def concat_ctm(self, ctm):
    # This is really tortured and may cause performance problems.
    # Unfortunately I don't see a much better way right now.
        if '__class__' in dir(ctm) and ctm.__class__.__name__.count('AffineMatrix'):
            self.concat_ctm_agg(ctm)
        else:
            self.concat_ctm_agg(self.kivaaffine_to_aggaffine(ctm))
    def set_ctm(self, ctm):
        if '__class__' in dir(ctm) and ctm.__class__.__name__.count('AffineMatrix'):
            self.set_ctm_agg(ctm)
        else:
            self.set_ctm_agg(self.kivaaffine_to_aggaffine(ctm))


    def get_ctm(self, *args):
        return _gl.CompiledPath_get_ctm(self, *args)

    def save_ctm(self, *args):
        return _gl.CompiledPath_save_ctm(self, *args)

    def restore_ctm(self, *args):
        return _gl.CompiledPath_restore_ctm(self, *args)

    def total_vertices(self, *args):
        return _gl.CompiledPath_total_vertices(self, *args)

    def _rewind(self, *args):
        return _gl.CompiledPath__rewind(self, *args)

    def vertex(self, *args):
        return _gl.CompiledPath_vertex(self, *args)

    def _vertex(self, *args):
        return _gl.CompiledPath__vertex(self, *args)
    __swig_destroy__ = _gl.delete_CompiledPath
    __del__ = lambda self: None
CompiledPath_swigregister = _gl.CompiledPath_swigregister
CompiledPath_swigregister(CompiledPath)


from numpy import array, float64
def _vertices(self):
        """ This is only used for testing.  It allows us to retrieve
            all the vertices in the path at once.  The vertices are
            returned as an Nx4 array of the following format.

            x0, y0, cmd0, flag0
                x1, y1, cmd0, flag1
                ...
        """
        vertices = []
        self._rewind()
        cmd_flag = 1
        while cmd_flag != 0:
            pt, cmd_flag = self._vertex()
            cmd, flag = _gl.path_cmd(cmd_flag), _gl.path_flags(cmd_flag)
            vertices.append((pt[0],pt[1], cmd, flag))
        return array(vertices)

CompiledPath._vertices = _vertices


def get_kiva_ctm(self):
    aff = self.get_ctm()
    return array([[aff[0], aff[1], 0],
                  [aff[2], aff[3], 0],
                  [aff[4], aff[5], 1]], float64)

CompiledPath.get_kiva_ctm = get_kiva_ctm


class KivaGLFontType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, KivaGLFontType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, KivaGLFontType, name)
    __swig_setmethods__["size"] = _gl.KivaGLFontType_size_set
    __swig_getmethods__["size"] = _gl.KivaGLFontType_size_get
    if _newclass:
        size = _swig_property(_gl.KivaGLFontType_size_get, _gl.KivaGLFontType_size_set)
    __swig_setmethods__["name"] = _gl.KivaGLFontType_name_set
    __swig_getmethods__["name"] = _gl.KivaGLFontType_name_get
    if _newclass:
        name = _swig_property(_gl.KivaGLFontType_name_get, _gl.KivaGLFontType_name_set)
    __swig_setmethods__["family"] = _gl.KivaGLFontType_family_set
    __swig_getmethods__["family"] = _gl.KivaGLFontType_family_get
    if _newclass:
        family = _swig_property(_gl.KivaGLFontType_family_get, _gl.KivaGLFontType_family_set)
    __swig_setmethods__["style"] = _gl.KivaGLFontType_style_set
    __swig_getmethods__["style"] = _gl.KivaGLFontType_style_get
    if _newclass:
        style = _swig_property(_gl.KivaGLFontType_style_get, _gl.KivaGLFontType_style_set)
    __swig_setmethods__["encoding"] = _gl.KivaGLFontType_encoding_set
    __swig_getmethods__["encoding"] = _gl.KivaGLFontType_encoding_get
    if _newclass:
        encoding = _swig_property(_gl.KivaGLFontType_encoding_get, _gl.KivaGLFontType_encoding_set)
    __swig_setmethods__["filename"] = _gl.KivaGLFontType_filename_set
    __swig_getmethods__["filename"] = _gl.KivaGLFontType_filename_get
    if _newclass:
        filename = _swig_property(_gl.KivaGLFontType_filename_get, _gl.KivaGLFontType_filename_set)

    def __init__(self, *args):
        this = _gl.new_KivaGLFontType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def change_filename(self, *args):
        return _gl.KivaGLFontType_change_filename(self, *args)

    def is_loaded(self, *args):
        return _gl.KivaGLFontType_is_loaded(self, *args)

    def __repr__(self, *args):
        return _gl.KivaGLFontType___repr__(self, *args)

    def __eq__(self, *args):
        return _gl.KivaGLFontType___eq__(self, *args)
    __swig_destroy__ = _gl.delete_KivaGLFontType
    __del__ = lambda self: None
KivaGLFontType_swigregister = _gl.KivaGLFontType_swigregister
KivaGLFontType_swigregister(KivaGLFontType)


def unicode_safe_init(self, _name="Arial", _size=12, _family=0, _style=0,
                      _encoding=0, validate=True):
### HACK:  C++ stuff expects a string (not unicode) for the face_name, so fix
###        if needed.
### Only for python < 3
    if '' == b'':
        if isinstance(_name, unicode):
            _name = _name.encode("latin1")
    else:
        if isinstance(_name, bytes):
            _name = _name.decode()
    obj = _gl.new_KivaGLFontType(_name, _size, _family, _style,
                               _encoding, validate)
    _swig_setattr(self, KivaGLFontType, "this", obj)
    _swig_setattr(self, KivaGLFontType, "thisown", 1)

# This is a crappy way of overriding the constructor
KivaGLFontType.__init__ = unicode_safe_init

class GraphicsContextGL(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GraphicsContextGL, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GraphicsContextGL, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _gl.new_GraphicsContextGL(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gl.delete_GraphicsContextGL
    __del__ = lambda self: None

    def gl_init(self, *args):
        return _gl.GraphicsContextGL_gl_init(self, *args)

    def gl_cleanup(self, *args):
        return _gl.GraphicsContextGL_gl_cleanup(self, *args)

    def gl_render_path(self, *args):
        return _gl.GraphicsContextGL_gl_render_path(self, *args)

    def gl_render_points(self, *args):
        return _gl.GraphicsContextGL_gl_render_points(self, *args)

    def bottom_up(self, *args):
        return _gl.GraphicsContextGL_bottom_up(self, *args)

    def width(self, *args):
        return _gl.GraphicsContextGL_width(self, *args)

    def height(self, *args):
        return _gl.GraphicsContextGL_height(self, *args)

    def stride(self, *args):
        return _gl.GraphicsContextGL_stride(self, *args)

    def save_state(self, *args):
        return _gl.GraphicsContextGL_save_state(self, *args)

    def restore_state(self, *args):
        return _gl.GraphicsContextGL_restore_state(self, *args)

    def flush(self, *args):
        return _gl.GraphicsContextGL_flush(self, *args)

    def synchronize(self, *args):
        return _gl.GraphicsContextGL_synchronize(self, *args)

    def begin_page(self, *args):
        return _gl.GraphicsContextGL_begin_page(self, *args)

    def end_page(self, *args):
        return _gl.GraphicsContextGL_end_page(self, *args)

    def translate_ctm(self, *args):
        return _gl.GraphicsContextGL_translate_ctm(self, *args)

    def rotate_ctm(self, *args):
        return _gl.GraphicsContextGL_rotate_ctm(self, *args)

    def scale_ctm(self, *args):
        return _gl.GraphicsContextGL_scale_ctm(self, *args)

    def concat_ctm(self, m):
        if isinstance(m, tuple):
            _gl.GraphicsContextGL_concat_ctm(self, _AffineMatrix(*m))
        else:
            _gl.GraphicsContextGL_concat_ctm(self, m)



    def set_ctm(self, m):
        if isinstance(m, tuple):
            _gl.GraphicsContextGL_set_ctm(self, _AffineMatrix(*m))
        else:
            _gl.GraphicsContextGL_set_ctm(self, m)



    def get_ctm(self):
        tmp = _gl.GraphicsContextGL_get_ctm(self)
        return (tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5])



    def format(self):
        enum = _gl.GraphicsContextGL_format(self)
        return pix_format_enum_map[enum]



    def get_image_interpolation(self):
        enum = _gl.GraphicsContextGL_get_image_interpolation(self)
        return interp_enum_map[enum]



    def set_image_interpolation(self,interp):
        enum = interp_string_map[interp]
        _gl.GraphicsContextGL_set_image_interpolation(self, enum)



    def set_stroke_color(self, color):
        if is_array(color) and len(color) == 3:
            ary = color
            r, g, b = ary
            color = Rgba(r, g, b)
        elif is_array(color) and len(color) == 4:
            ary = color
            r, g, b, a = ary
            color = Rgba(r, g, b, a)
        _gl.GraphicsContextGL_set_stroke_color(self, color)



    def get_stroke_color(self, *args):
        return _gl.GraphicsContextGL_get_stroke_color(self, *args)

    def set_fill_color(self, color):
        if is_array(color) and len(color) == 3:
            ary = color
            r, g, b = ary
            color = Rgba(r, g, b)
        elif is_array(color) and len(color) == 4:
            ary = color
            r, g, b, a = ary
            color = Rgba(r, g, b, a)
        _gl.GraphicsContextGL_set_fill_color(self, color)



    def get_fill_color(self, *args):
        return _gl.GraphicsContextGL_get_fill_color(self, *args)

    def set_alpha(self, *args):
        return _gl.GraphicsContextGL_set_alpha(self, *args)

    def get_alpha(self, *args):
        return _gl.GraphicsContextGL_get_alpha(self, *args)

    def set_antialias(self, *args):
        return _gl.GraphicsContextGL_set_antialias(self, *args)

    def get_antialias(self, *args):
        return _gl.GraphicsContextGL_get_antialias(self, *args)

    def set_miter_limit(self, *args):
        return _gl.GraphicsContextGL_set_miter_limit(self, *args)

    def set_flatness(self, *args):
        return _gl.GraphicsContextGL_set_flatness(self, *args)

    def set_line_width(self, *args):
        return _gl.GraphicsContextGL_set_line_width(self, *args)

    def set_line_join(self, *args):
        return _gl.GraphicsContextGL_set_line_join(self, *args)

    def set_line_cap(self, *args):
        return _gl.GraphicsContextGL_set_line_cap(self, *args)

    def set_line_dash(self, *args):
        return _gl.GraphicsContextGL_set_line_dash(self, *args)

    def set_blend_mode(self, *args):
        return _gl.GraphicsContextGL_set_blend_mode(self, *args)

    def get_blend_mode(self, *args):
        return _gl.GraphicsContextGL_get_blend_mode(self, *args)

    def begin_path(self, *args):
        return _gl.GraphicsContextGL_begin_path(self, *args)

    def move_to(self, *args):
        return _gl.GraphicsContextGL_move_to(self, *args)

    def line_to(self, *args):
        return _gl.GraphicsContextGL_line_to(self, *args)

    def curve_to(self, *args):
        return _gl.GraphicsContextGL_curve_to(self, *args)

    def quad_curve_to(self, *args):
        return _gl.GraphicsContextGL_quad_curve_to(self, *args)

    def arc(self, *args):
        return _gl.GraphicsContextGL_arc(self, *args)

    def arc_to(self, *args):
        return _gl.GraphicsContextGL_arc_to(self, *args)

    def close_path(self, *args):
        return _gl.GraphicsContextGL_close_path(self, *args)

    def add_path(self, *args):
        return _gl.GraphicsContextGL_add_path(self, *args)

    def lines(self, *args):
        return _gl.GraphicsContextGL_lines(self, *args)

    def line_set(self, *args):
        return _gl.GraphicsContextGL_line_set(self, *args)

    def rect(self, *args):
        return _gl.GraphicsContextGL_rect(self, *args)

    def rects(self, *args):
        return _gl.GraphicsContextGL_rects(self, *args)

    def _get_path(self, *args):
        return _gl.GraphicsContextGL__get_path(self, *args)

    def clip(self, *args):
        return _gl.GraphicsContextGL_clip(self, *args)

    def even_odd_clip(self, *args):
        return _gl.GraphicsContextGL_even_odd_clip(self, *args)

    def clip_to_rect(self, *args):
        return _gl.GraphicsContextGL_clip_to_rect(self, *args)

    def clip_to_rects(self, *args):
        return _gl.GraphicsContextGL_clip_to_rects(self, *args)

    def transform_clip_rectangle(self, *args):
        return _gl.GraphicsContextGL_transform_clip_rectangle(self, *args)

    def clear_clip_path(self, *args):
        return _gl.GraphicsContextGL_clear_clip_path(self, *args)

    def get_num_clip_regions(self, *args):
        return _gl.GraphicsContextGL_get_num_clip_regions(self, *args)

    def get_clip_region(self, *args):
        return _gl.GraphicsContextGL_get_clip_region(self, *args)

    def clear(self, *args):
        return _gl.GraphicsContextGL_clear(self, *args)

    def fill_path(self, *args):
        return _gl.GraphicsContextGL_fill_path(self, *args)

    def eof_fill_path(self, *args):
        return _gl.GraphicsContextGL_eof_fill_path(self, *args)

    def stroke_path(self, *args):
        return _gl.GraphicsContextGL_stroke_path(self, *args)

    def _stroke_path(self, *args):
        return _gl.GraphicsContextGL__stroke_path(self, *args)

    def draw_path(self, *args):
        return _gl.GraphicsContextGL_draw_path(self, *args)

    def draw_rect(self, *args):
        return _gl.GraphicsContextGL_draw_rect(self, *args)

    def draw_marker_at_points(self, pts, size, kiva_marker_type):
        marker = kiva_marker_to_agg.get(kiva_marker_type, None)
        if marker is None:
            success = 0
        else:
            args = (self, pts, int(size), marker)
            success = _gl.GraphicsContextGL_draw_marker_at_points(
                self, pts, int(size), marker
            )
        return success



    def draw_path_at_points(self, *args):
        return _gl.GraphicsContextGL_draw_path_at_points(self, *args)

    def draw_image(self, *args):
        return _gl.GraphicsContextGL_draw_image(self, *args)

    def show_text(self, text, point = None):
        """Displays text at point, or at the current text pen position
           if point is None.  Returns true if text displayed properly,
           false if there was a font issue or a glyph could not be
           rendered.  Will handle multi-line text separated by backslash-ns
        """
        raise RuntimeError("Text is not supported by OpenGL.")

    def show_text_at_point(self, text, dx, dy):
        raise RuntimeError("Text is not supported by OpenGL.")

    def get_text_extent(self, text):
        raise RuntimeError("Text is not supported by OpenGL.")

    def get_full_text_extent(self, text):
        raise RuntimeError("Text is not supported by OpenGL.")

    def get_font(self):
        raise RuntimeError("Text is not supported by OpenGL.")

    def set_font(self, font):
        raise RuntimeError("Unable to load font.")

    def is_font_initialized(self):
        raise RuntimeError("Font not loaded/initialized.")

    def set_font_size(self, size):
        raise RuntimeError("Font not loaded/initialized.")

    def get_freetype_text_matrix(self, *args):
        raise RuntimeError("Text is not supported by OpenGL.")

    def get_text_matrix(self, matrix):
        raise RuntimeError("Text is not supported by OpenGL.")

    def set_text_matrix(self, matrix):
        raise RuntimeError("Text is not supported by OpenGL.")

    def set_text_position(self, tx, ty):
        raise RuntimeError("Text is not supported by OpenGL")

    def get_text_position(self):
        raise RuntimeError("Text is not supported by OpenGL")

    def set_character_spacing(self, value):
        raise RuntimeError("Text is not supported by OpenGL.")

    def get_character_spacing(self):
        raise RuntimeError("Text is not supported by OpenGL.")

    def set_text_drawing_mode(self, value):
        raise RuntimeError("Text is not supported by OpenGL.")



    def linear_gradient(self, x1, y1, x2, y2, stops, spread_method, units="userSpaceOnUse"):
        raise NotImplementedError("Gradient fills are not supported by OpenGL")

    def radial_gradient(self, cx, cy, r, fx, fy, stops, spread_method, units="userSpaceOnUse"):
        raise NotImplementedError("Gradient fills are not supported by OpenGL")



    def get_empty_path(self):
        return CompiledPath()

    def convert_pixel_format(self, pix_format, inplace=0):
        """ Convert gc from one pixel format to another.

        NOTE: This has never worked on OpenGL, because draw_image has never
        been implemented. It used to inherit the GraphicsContextArry
        implementation, which relied on the context having a working
        implementation of draw_image which would handle the pixel format
        conversion.
        """
        return self.__class__(self.width(), self.height(), pix_format=pix_format)

    def save(self, filename, file_format=None, pil_options=None):
        """ Save the GraphicsContext to a file.

        NOTE: This has never worked on OpenGL, because it draws this
        context into an image context by using the agg `rendering_buffer`
        as a source of pixel data. The buffer is never used with OpenGL,
        so it is always blank.
        """
        raise RuntimeError("Saving is not supported by OpenGL.")

    #----------------------------------------------------------------
    # context manager interface
    #----------------------------------------------------------------

    def __enter__(self):
        self.save_state()

    def __exit__(self, type, value, traceback):
        self.restore_state()


GraphicsContextGL_swigregister = _gl.GraphicsContextGL_swigregister
GraphicsContextGL_swigregister(GraphicsContextGL)

# This file is compatible with both classic and new-style classes.


